(# 三层神经网络)
(# 能计算异或)
(# 这玩意要迭代得比较久)
(# 迭代到200多次才会往正确的方向拟合)
(# 之前只迭代100次)
(# 结果把我骗惨了)
(# (〃′皿`)q)
(# 样本文件是sample-XOR.txt)
(# 另外outfile.txt是1000次迭代记录)
(public
   c (&(chr 13)(chr 10))
)
(fn vector_mul (v1 v2)
   (def x 0)
   (while (<= x (size v1))(
      (def y 0)
      (while(<= y (size(m v1 0)))(
         (array v1 (x y) (*(m v1 x y)(m v2 x y)))     
         (def y(+ y 1))
         )
      )
      (def x(+ x 1))
      )
   )
   (return v1)
)
(# 向量乘法)
(fn matrix_mus(m1 m2)
   (def j 0)
   (while (<= j (size m1))(
      (def z 0)
      (while (<= z (size(m m1 0)))(
         (array m1 (j z) (-(m m1 j z)(m m2 j z)))
         (def z (+ z 1))
         )
      )
      (def j (+ j 1))
      )
   )
   (return m1)
)
(# 矩阵减法)
(fn matrix_add(m1 m2)
   (def j 0)
   (while (<= j (size m1))(
      (def z 0)
      (while (<= z (size(m m1 0)))(
         (array m1 (j z) (+(m m1 j z)(m m2 j z)))
         (def z (+ z 1))
         )
      )
      (def j (+ j 1))
      )
   )
   (return m1)
)
(# 矩阵加法)
(fn matrix_t (matrix)
   (def newsp (alloc (size (m matrix 0))))
   (def i 0)
   (while (<= i (size matrix))(      
      (array newsp (i) (alloc(size matrix)))
      (def i (+ i 1))
      )
   )
   (def j 0)
   (while (<= j (size matrix))(
      (def z 0)
      (while (<= z (size(m matrix 0)))(
         (array newsp (z j) (m matrix j z))
         (def z (+ z 1))
         )
      )
      (def j (+ j 1))
      )
   )
   (return newsp)
)
(# 矩阵转置)
(fn sig(n)
   (return (/ 1 (+ 1 (exp (- 0 n)))))
)
(# 激活算法Sigmoid)
(fn active(matrix pattern)
   (def j 0)
   (while (<= j (size matrix))(
      (def z 0)
      (while (<= z (size(m matrix 0)))(
         (def x (m matrix j z))
         (if(= pattern 1)
            (array matrix (j z) (sig x))
            (array matrix (j z) (* x(- 1 x)))
         )
         (def z (+ z 1))
         )
      )
      (def j (+ j 1))
      )
   )
   (return matrix)
)
(# 激活)
(fn matrix_mul (m1 m2)
   (def x (size m1))
   (def new_space (alloc(size (m m2 0))))
   (def i 0)
   (while(<= i (size new_space))(
      (array new_space (i) 0)
      (def i (+ i 1))
      )
   )
   (def new_m (alloc x))
   (def i 0)
   (while (<= i x)(      
      (array new_m (i) new_space)
      (def i (+ i 1))
      )
   )
   (def i 0)
   (while (<= i (size new_m))(
      (def j 0)
      (while (<= j (size (m new_m 0)))(
         (def z 0)
         (while (<= z (size(m m1 0)))(
            (array new_m (i j) (+ (m new_m i j)(*(m m1 i z)(m m2 z j))))
            (def z (+ z 1))
            )
         )
         (def j (+ j 1))
         )
      )
      (def i (+ i 1))
      )
   )
   (return new_m)
)
(# 矩阵乘法)
(fn matrix_op(m1)
   (def grid "")
   (def j 0)
   (while (<= j (size m1))(
      (def z 0)
      (while (<= z (size(m m1 0)))(
         (def grid(& grid(m m1 j z) " "))
         (def z (+ z 1))
         )
      )
      (def grid(& grid c))
      (def j (+ j 1))
      )
   )
   (return grid)
)
(# 矩阵输出)
(main
   (def f_p (in "Input sample file path:"))
   (def inner(read f_p))
   (def each_line(split inner (&(chr 13)(chr 10))))
   (def x 0)
   (def outf "outfile.txt")
   (def ot "")
   (def m1 (alloc (-(size each_line)1)))
   (def std (alloc (-(size each_line)1)))
   (while (<= x(size m1))(
      (def single(split (m each_line x)" "))
      (array m1 (x)(list(m single 0)(m single 1)(m single 2)))
      (array std (x)(list(m single 3)))
      (def x (+ x 1))
      )
   )
   (# m1:输入矩阵)
   (# std:标准输出矩阵)
   (def syn0(list(list(rand 1)(rand 1)(rand 1)(rand 1))
   (list(rand 1)(rand 1)(rand 1)(rand 1))
   (list(rand 1)(rand 1)(rand 1)(rand 1))))
   (def syn1(list(list (rand 1))(list (rand 1))(list (rand 1))(list (rand 1))))   
   (# 神经突触（机器产生输出）)
   (# m1是输入层)
   (# l0、l1是隐藏层)
   (def iter 0)
   (while (< iter 1000)((# 迭代1000次)
      (def l0 (active (matrix_mul m1 syn0) 1))
      (def l1 (active (matrix_mul l0 syn1) 1))
      (def err1 (matrix_mus std l1))
      (def delta1 (vector_mul err1 (active l1 2)))
      (def err0 (matrix_mul delta1 (matrix_t syn1)))
      (def delta0 (vector_mul  err0 (active l0 2)))
      (def syn1(matrix_add (matrix_mul(matrix_t l0)delta1)syn1))
      (def syn0(matrix_add (matrix_mul(matrix_t m1)delta0)syn0))
      (def iter (+ iter 1))
      (if(=(% iter 10)0)(
         (def ot(& ot "第" iter "次输出：" c (matrix_op l1) "---------------" c))
         (outfile outf ot)
         )
      )
      )
   )
   (out(matrix_op l1))
   (# 机器输出)
)