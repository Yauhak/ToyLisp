(# 双层神经网络)
(# 注意：此神经网络并不稳定)
(# 只能感知具有线性关系的线性代数间的联系)
(# 对于异或这样的运算就没戏)
(# 不过至少说明我的ToyLisp挺强大的)
(# PS:线性代数太难了)
(# (^ω^))
(public
   c (chr 13)
)
(fn vector_mul (v1 v2)
   (def x 0)
   (while (<= x (size v1))(
      (array v1 (x 0) (*(m v1 x 0)(m v2 x 0)))     
      (def x(+ x 1))
      )
   )
   (return v1)
)
(# 向量乘法)
(fn matrix_mus(m1 m2)
   (def j 0)
   (while (<= j (size m1))(
      (def z 0)
      (while (<= z (size(m m1 0)))(
         (array m1 (j z) (-(m m1 j z)(m m2 j z)))
         (def z (+ z 1))
         )
      )
      (def j (+ j 1))
      )
   )
   (return m1)
)
(# 矩阵减法)
(fn matrix_add(m1 m2)
   (def j 0)
   (while (<= j (size m1))(
      (def z 0)
      (while (<= z (size(m m1 0)))(
         (array m1 (j z) (+(m m1 j z)(m m2 j z)))
         (def z (+ z 1))
         )
      )
      (def j (+ j 1))
      )
   )
   (return m1)
)
(# 矩阵加法)
(fn matrix_t (matrix)
   (def newsp (alloc (size (m matrix 0))))
   (def i 0)
   (while (<= i (size matrix))(      
      (array newsp (i) (alloc(size matrix)))
      (def i (+ i 1))
      )
   )
   (def j 0)
   (while (<= j (size matrix))(
      (def z 0)
      (while (<= z (size(m matrix 0)))(
         (array newsp (z j) (m matrix j z))
         (def z (+ z 1))
         )
      )
      (def j (+ j 1))
      )
   )
   (return newsp)
)
(# 矩阵转置)
(fn sig(n)
   (return (/ 1 (+ 1 (exp (- 0 n)))))
)
(# 激活算法Sigmoid)
(fn active(matrix pattern)
   (def j 0)
   (while (<= j (size matrix))(
      (def z 0)
      (while (<= z (size(m matrix 0)))(
         (def x (m matrix j z))
         (if(= pattern 1)
            (array matrix (j z) (sig x))
            (array matrix (j z) (* x(- 1 x)))
         )
         (def z (+ z 1))
         )
      )
      (def j (+ j 1))
      )
   )
   (return matrix)
)
(# 激活)
(fn matrix_mul (m1 m2)
   (def x (size m1))
   (def new_space (alloc(size (m m2 0))))
   (def i 0)
   (while(<= i (size new_space))(
      (array new_space (i) 0)
      (def i (+ i 1))
      )
   )
   (def new_m (alloc x))
   (def i 0)
   (while (<= i x)(      
      (array new_m (i) new_space)
      (def i (+ i 1))
      )
   )
   (def i 0)
   (while (<= i (size new_m))(
      (def j 0)
      (while (<= j (size (m new_m 0)))(
         (def z 0)
         (while (<= z (size(m m1 0)))(
            (array new_m (i j) (+ (m new_m i j)(*(m m1 i z)(m m2 z j))))
            (def z (+ z 1))
            )
         )
         (def j (+ j 1))
         )
      )
      (def i (+ i 1))
      )
   )
   (return new_m)
)
(# 矩阵乘法)
(fn matrix_op(m1)
   (def grid "")
   (def j 0)
   (while (<= j (size m1))(
      (def z 0)
      (while (<= z (size(m m1 0)))(
         (def grid(& grid(m m1 j z) " "))
         (def z (+ z 1))
         )
      )
      (def grid(& grid c))
      (def j (+ j 1))
      )
   )
   (out grid)
)
(# 矩阵输出)
(main
   (def m1(list(list 0 0 1)(list 1 0 1)(list 0 1 1)(list 1 1 1)))
   (# 输入矩阵)
   (def std(list(list 0)(list 1)(list 0)(list 1)))
   (# 标准输出矩阵)
   (def syn(list(list (rand 1))(list (rand 1))(list (rand 1))))   
   (# 神经突触（机器产生输出）)
   (def iter 0)
   (while (< iter 100)((# 迭代100次)
      (def l1 (active (matrix_mul m1 syn) 1))
      (def err (matrix_mus std l1))
      (def delta (vector_mul err (active l1 2)))
      (def syn (matrix_add syn (matrix_mul (matrix_t m1) delta)))
      (def iter (+ iter 1))
      )
   )
   (# 虽说迭代100次不够精确（解释器性能有限）)
   (# 但确实有趋向标准输出的趋势)
   (matrix_op l1)
   (# 机器输出)
)